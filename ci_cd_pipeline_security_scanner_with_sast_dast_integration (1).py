# -*- coding: utf-8 -*-
"""CI/CD Pipeline Security Scanner with SAST/DAST Integration

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y1sEyvWd3UiDWmKNrdVAn4E3hqiXSSDK
"""

"""
DevOps Project 4: CI/CD Pipeline Security Scanner with SAST/DAST Integration
An advanced security scanning system that integrates Static (SAST) and Dynamic (DAST)
analysis into CI/CD pipelines, detecting vulnerabilities, secrets, and security misconfigurations
with ML-based risk scoring and automated remediation suggestions.
"""

import numpy as np
import pandas as pd
from datetime import datetime, timedelta
import matplotlib.pyplot as plt
import seaborn as sns
import re
import hashlib
import json
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
import warnings
warnings.filterwarnings('ignore')

class CICDSecurityScanner:
    def __init__(self):
        self.vulnerability_classifier = RandomForestClassifier(n_estimators=100, random_state=42)
        self.label_encoder = LabelEncoder()
        self.scan_results = {
            'sast': [],
            'dast': [],
            'secrets': [],
            'dependencies': [],
            'container': []
        }
        self.risk_score = 0
        self.pipeline_stages = []

    def simulate_codebase(self):
        """Generate simulated code files with various security issues"""
        code_files = {
            'app.py': '''
import os
import sqlite3
from flask import Flask, request

app = Flask(__name__)
SECRET_KEY = "EXAMPLE_SECRET_DO_NOT_USE"
API_KEY = "EXAMPLE_API_KEY_PATTERN"

@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']

    # SQL Injection vulnerability
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    conn = sqlite3.connect('database.db')
    result = conn.execute(query)

    return "Login successful"

@app.route('/upload', methods=['POST'])
def upload_file():
    file = request.files['file']
    # Path traversal vulnerability
    filename = request.form['filename']
    file.save(f'/uploads/{filename}')
    return "File uploaded"

@app.route('/api/data')
def get_data():
    # Missing authentication
    data = {"secret": "sensitive_data"}
    return data

if __name__ == '__main__':
    # Insecure configuration
    app.run(debug=True, host='0.0.0.0')
''',
            'config.json': '''{
    "database": {
        "host": "prod-db.internal",
        "username": "admin",
        "password": "Admin123!@#",
        "port": 5432
    },
    "aws": {
        "access_key": "EXAMPLE_AWS_KEY_PATTERN",
        "secret_key": "EXAMPLE_AWS_SECRET_PATTERN"
    },
    "stripe": {
        "api_key": "EXAMPLE_STRIPE_KEY_PATTERN"
    }
}''',
            'Dockerfile': '''FROM ubuntu:18.04
RUN apt-get update
RUN apt-get install -y python3
COPY . /app
WORKDIR /app
USER root
EXPOSE 80
CMD ["python3", "app.py"]
''',
            'requirements.txt': '''Flask==0.12.0
requests==2.6.0
django==1.11.0
urllib3==1.24.1
jinja2==2.10.0
PyYAML==5.3.0
pillow==6.2.0
''',
            'deploy.sh': '''#!/bin/bash
export AWS_ACCESS_KEY_ID="EXAMPLE_KEY_PATTERN"
export AWS_SECRET_ACCESS_KEY="EXAMPLE_SECRET_PATTERN"
export DB_PASSWORD="EXAMPLE_PASSWORD"

curl -X POST http://api.example.com/deploy \\
  -H "Authorization: Bearer EXAMPLE_TOKEN" \\
  -d "version=latest"
'''
        }

        return code_files

    def run_sast_scan(self, code_files):
        """Static Application Security Testing - analyze source code"""
        print("\nüîç Running SAST (Static Analysis)...")

        vulnerabilities = []

        for filename, content in code_files.items():
            # Check for SQL Injection
            if re.search(r'execute\([\'"].*\{.*\}.*[\'"]\)', content) or \
               re.search(r'f["\']SELECT.*FROM.*WHERE.*["\']', content):
                vulnerabilities.append({
                    'type': 'SQL Injection',
                    'severity': 'CRITICAL',
                    'file': filename,
                    'line': self._find_line_number(content, 'SELECT'),
                    'description': 'SQL query constructed using string formatting - vulnerable to injection',
                    'cwe': 'CWE-89',
                    'owasp': 'A03:2021 - Injection',
                    'remediation': 'Use parameterized queries or ORM',
                    'code_snippet': 'query = f"SELECT * FROM users WHERE..."'
                })

            # Check for hardcoded secrets
            secret_patterns = [
                (r'SECRET_KEY\s*=\s*["\'][^"\']+["\']', 'Hardcoded Secret Key'),
                (r'API_KEY\s*=\s*["\']sk-[a-zA-Z0-9]+["\']', 'Hardcoded API Key'),
                (r'password\s*[=:]\s*["\'][^"\']+["\']', 'Hardcoded Password'),
                (r'AKIA[0-9A-Z]{16}', 'AWS Access Key'),
                (r'sk_live_[0-9a-zA-Z]{24,}', 'Stripe API Key')
            ]

            for pattern, vuln_type in secret_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': vuln_type,
                        'severity': 'CRITICAL',
                        'file': filename,
                        'line': self._find_line_number(content, pattern),
                        'description': f'{vuln_type} found in source code',
                        'cwe': 'CWE-798',
                        'owasp': 'A07:2021 - Identification and Authentication Failures',
                        'remediation': 'Use environment variables or secret management service',
                        'code_snippet': 'SECRET_KEY = "hardcoded..."'
                    })

            # Check for Path Traversal
            if re.search(r'\.save\([\'"]?/.*\{.*\}', content) or \
               re.search(r'open\(.*request\.', content):
                vulnerabilities.append({
                    'type': 'Path Traversal',
                    'severity': 'HIGH',
                    'file': filename,
                    'line': self._find_line_number(content, 'save'),
                    'description': 'User input used in file path without validation',
                    'cwe': 'CWE-22',
                    'owasp': 'A01:2021 - Broken Access Control',
                    'remediation': 'Validate and sanitize file paths, use allowlist',
                    'code_snippet': 'file.save(f"/uploads/{filename}")'
                })

            # Check for insecure configurations
            if re.search(r'debug\s*=\s*True', content, re.IGNORECASE):
                vulnerabilities.append({
                    'type': 'Debug Mode Enabled',
                    'severity': 'MEDIUM',
                    'file': filename,
                    'line': self._find_line_number(content, 'debug'),
                    'description': 'Debug mode enabled in production code',
                    'cwe': 'CWE-489',
                    'owasp': 'A05:2021 - Security Misconfiguration',
                    'remediation': 'Disable debug mode in production',
                    'code_snippet': 'app.run(debug=True)'
                })

            # Check for missing authentication
            if re.search(r'@app\.route.*\n.*def.*\n.*(?!.*@login_required)', content):
                vulnerabilities.append({
                    'type': 'Missing Authentication',
                    'severity': 'HIGH',
                    'file': filename,
                    'line': self._find_line_number(content, '@app.route'),
                    'description': 'API endpoint without authentication',
                    'cwe': 'CWE-306',
                    'owasp': 'A07:2021 - Identification and Authentication Failures',
                    'remediation': 'Add authentication decorator to protected routes',
                    'code_snippet': '@app.route("/api/data")'
                })

        self.scan_results['sast'] = vulnerabilities
        print(f"  ‚úì Found {len(vulnerabilities)} SAST vulnerabilities")
        return vulnerabilities

    def run_secrets_scan(self, code_files):
        """Scan for exposed secrets and credentials"""
        print("\nüîê Running Secrets Detection...")

        secrets_found = []

        secret_patterns = {
            'AWS Access Key': r'AKIA[0-9A-Z]{16}',
            'AWS Secret Key': r'[0-9a-zA-Z/+]{40}',
            'Private Key': r'-----BEGIN (RSA|DSA|EC|OPENSSH) PRIVATE KEY-----',
            'Generic API Key': r'api[_-]?key[\'"]?\s*[:=]\s*[\'"][a-zA-Z0-9_\-]{20,}[\'"]',
            'Generic Secret': r'secret[\'"]?\s*[:=]\s*[\'"][a-zA-Z0-9_\-]{10,}[\'"]',
            'Password': r'password[\'"]?\s*[:=]\s*[\'"][^\'"\s]{6,}[\'"]',
            'JWT Token': r'eyJ[A-Za-z0-9-_=]+\.eyJ[A-Za-z0-9-_=]+\.[A-Za-z0-9-_.+/=]*',
            'Stripe API Key': r'sk_(live|test)_[0-9a-zA-Z]{24,}',
            'GitHub Token': r'ghp_[0-9a-zA-Z]{36}',
            'Slack Token': r'xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[a-zA-Z0-9]{24,}'
        }

        for filename, content in code_files.items():
            for secret_type, pattern in secret_patterns.items():
                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                for match in matches:
                    secret_value = match.group(0)
                    secrets_found.append({
                        'type': secret_type,
                        'severity': 'CRITICAL',
                        'file': filename,
                        'line': content[:match.start()].count('\n') + 1,
                        'secret_hash': hashlib.sha256(secret_value.encode()).hexdigest()[:16],
                        'exposure_risk': 'HIGH',
                        'remediation': f'Remove {secret_type} from code, use secret management',
                        'leaked_to_git': np.random.choice([True, False])
                    })

        self.scan_results['secrets'] = secrets_found
        print(f"  ‚úì Found {len(secrets_found)} exposed secrets")
        return secrets_found

    def run_dependency_scan(self, requirements_file):
        """Scan dependencies for known vulnerabilities"""
        print("\nüì¶ Running Dependency Vulnerability Scan...")

        # Simulate known vulnerabilities database
        known_vulns = {
            'Flask==0.12.0': {
                'cve': 'CVE-2018-1000656',
                'severity': 'HIGH',
                'description': 'Improper input validation in Flask',
                'fixed_version': '1.0.0'
            },
            'requests==2.6.0': {
                'cve': 'CVE-2018-18074',
                'severity': 'HIGH',
                'description': 'Credential exposure in requests',
                'fixed_version': '2.20.0'
            },
            'django==1.11.0': {
                'cve': 'CVE-2019-6975',
                'severity': 'CRITICAL',
                'description': 'Memory exhaustion in django.utils.numberformat',
                'fixed_version': '1.11.28'
            },
            'urllib3==1.24.1': {
                'cve': 'CVE-2020-26137',
                'severity': 'MEDIUM',
                'description': 'CRLF injection via HTTP request method',
                'fixed_version': '1.25.9'
            },
            'jinja2==2.10.0': {
                'cve': 'CVE-2020-28493',
                'severity': 'MEDIUM',
                'description': 'ReDoS vulnerability in Jinja2',
                'fixed_version': '2.11.3'
            },
            'PyYAML==5.3.0': {
                'cve': 'CVE-2020-14343',
                'severity': 'CRITICAL',
                'description': 'Arbitrary code execution in PyYAML',
                'fixed_version': '5.4.0'
            },
            'pillow==6.2.0': {
                'cve': 'CVE-2020-35653',
                'severity': 'HIGH',
                'description': 'Buffer overflow in Pillow',
                'fixed_version': '8.1.1'
            }
        }

        vulnerabilities = []
        dependencies = requirements_file.strip().split('\n')

        for dep in dependencies:
            if dep in known_vulns:
                vuln = known_vulns[dep]
                vulnerabilities.append({
                    'package': dep.split('==')[0],
                    'current_version': dep.split('==')[1],
                    'vulnerability': vuln['cve'],
                    'severity': vuln['severity'],
                    'description': vuln['description'],
                    'fixed_version': vuln['fixed_version'],
                    'remediation': f'Upgrade to version {vuln["fixed_version"]} or later',
                    'cvss_score': self._calculate_cvss_score(vuln['severity'])
                })

        self.scan_results['dependencies'] = vulnerabilities
        print(f"  ‚úì Found {len(vulnerabilities)} vulnerable dependencies")
        return vulnerabilities

    def run_container_scan(self, dockerfile):
        """Scan Docker container for security issues"""
        print("\nüê≥ Running Container Security Scan...")

        issues = []
        lines = dockerfile.split('\n')

        for i, line in enumerate(lines, 1):
            # Check for outdated base image
            if 'FROM' in line and 'ubuntu:18.04' in line:
                issues.append({
                    'type': 'Outdated Base Image',
                    'severity': 'MEDIUM',
                    'line': i,
                    'description': 'Using outdated Ubuntu 18.04 (EOL)',
                    'remediation': 'Update to ubuntu:22.04 or later',
                    'code': line.strip()
                })

            # Check for running as root
            if 'USER root' in line:
                issues.append({
                    'type': 'Running as Root',
                    'severity': 'HIGH',
                    'line': i,
                    'description': 'Container runs with root privileges',
                    'remediation': 'Create non-root user and use USER directive',
                    'code': line.strip()
                })

            # Check for exposed privileged ports
            if 'EXPOSE' in line and ('80' in line or '22' in line):
                issues.append({
                    'type': 'Privileged Port Exposed',
                    'severity': 'MEDIUM',
                    'line': i,
                    'description': 'Exposing privileged port (<1024)',
                    'remediation': 'Use non-privileged ports (>1024)',
                    'code': line.strip()
                })

            # Check for missing health check
            if 'CMD' in line or 'ENTRYPOINT' in line:
                if not any('HEALTHCHECK' in l for l in lines):
                    issues.append({
                        'type': 'Missing Health Check',
                        'severity': 'LOW',
                        'line': i,
                        'description': 'No HEALTHCHECK instruction defined',
                        'remediation': 'Add HEALTHCHECK instruction',
                        'code': 'HEALTHCHECK CMD curl --fail http://localhost/ || exit 1'
                    })

        # Check for security best practices
        if not any('apt-get clean' in line or 'rm -rf /var/lib/apt/lists' in line for line in lines):
            issues.append({
                'type': 'Unnecessary Files',
                'severity': 'LOW',
                'line': 0,
                'description': 'APT cache not cleaned, increases image size',
                'remediation': 'Add: RUN apt-get clean && rm -rf /var/lib/apt/lists/*',
                'code': 'RUN apt-get clean && rm -rf /var/lib/apt/lists/*'
            })

        self.scan_results['container'] = issues
        print(f"  ‚úì Found {len(issues)} container security issues")
        return issues

    def run_dast_scan(self):
        """Dynamic Application Security Testing - runtime analysis"""
        print("\nüåê Running DAST (Dynamic Analysis)...")

        # Simulate runtime vulnerabilities
        runtime_vulns = [
            {
                'type': 'Missing Security Headers',
                'severity': 'MEDIUM',
                'endpoint': 'https://app.example.com/',
                'description': 'Missing X-Frame-Options header',
                'remediation': 'Add X-Frame-Options: DENY header',
                'evidence': 'Response headers do not include X-Frame-Options'
            },
            {
                'type': 'Missing HSTS',
                'severity': 'MEDIUM',
                'endpoint': 'https://app.example.com/',
                'description': 'HTTP Strict Transport Security not set',
                'remediation': 'Add Strict-Transport-Security header',
                'evidence': 'No HSTS header in HTTPS response'
            },
            {
                'type': 'Cookie without Secure Flag',
                'severity': 'HIGH',
                'endpoint': 'https://app.example.com/login',
                'description': 'Session cookie missing Secure flag',
                'remediation': 'Set Secure and HttpOnly flags on cookies',
                'evidence': 'Set-Cookie: session=abc123; Path=/'
            },
            {
                'type': 'CORS Misconfiguration',
                'severity': 'HIGH',
                'endpoint': 'https://app.example.com/api',
                'description': 'CORS allows any origin (*)',
                'remediation': 'Restrict CORS to specific trusted origins',
                'evidence': 'Access-Control-Allow-Origin: *'
            },
            {
                'type': 'Information Disclosure',
                'severity': 'MEDIUM',
                'endpoint': 'https://app.example.com/error',
                'description': 'Stack trace exposed in error page',
                'remediation': 'Implement custom error pages',
                'evidence': 'Traceback (most recent call last)...'
            }
        ]

        self.scan_results['dast'] = runtime_vulns
        print(f"  ‚úì Found {len(runtime_vulns)} DAST vulnerabilities")
        return runtime_vulns

    def calculate_risk_score(self):
        """Calculate overall security risk score (0-100)"""
        severity_weights = {
            'CRITICAL': 10,
            'HIGH': 6,
            'MEDIUM': 3,
            'LOW': 1
        }

        total_score = 0
        max_score = 0

        # Calculate weighted scores for all scan types
        for scan_type, results in self.scan_results.items():
            for item in results:
                severity = item.get('severity', 'LOW')
                total_score += severity_weights.get(severity, 1)
                max_score += 10

        # Risk score: 0 (best) to 100 (worst)
        if max_score == 0:
            risk_score = 0
        else:
            risk_score = min(100, (total_score / max_score) * 100)

        self.risk_score = round(risk_score, 2)
        return self.risk_score

    def _find_line_number(self, content, pattern):
        """Find line number of pattern in content"""
        lines = content.split('\n')
        for i, line in enumerate(lines, 1):
            if re.search(pattern, line, re.IGNORECASE):
                return i
        return 1

    def _calculate_cvss_score(self, severity):
        """Calculate CVSS score based on severity"""
        scores = {
            'CRITICAL': round(np.random.uniform(9.0, 10.0), 1),
            'HIGH': round(np.random.uniform(7.0, 8.9), 1),
            'MEDIUM': round(np.random.uniform(4.0, 6.9), 1),
            'LOW': round(np.random.uniform(0.1, 3.9), 1)
        }
        return scores.get(severity, 5.0)

    def generate_pipeline_report(self):
        """Generate comprehensive security report"""
        print("\n" + "="*80)
        print("üîí CI/CD PIPELINE SECURITY SCAN REPORT")
        print("="*80)

        # Calculate statistics
        total_vulns = sum(len(results) for results in self.scan_results.values())

        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        for results in self.scan_results.values():
            for item in results:
                sev = item.get('severity', 'LOW')
                severity_counts[sev] += 1

        print("\nüìä SCAN SUMMARY")
        print("-" * 80)
        print(f"Total Vulnerabilities Found:    {total_vulns}")
        print(f"  ‚Ä¢ Critical:                   {severity_counts['CRITICAL']}")
        print(f"  ‚Ä¢ High:                       {severity_counts['HIGH']}")
        print(f"  ‚Ä¢ Medium:                     {severity_counts['MEDIUM']}")
        print(f"  ‚Ä¢ Low:                        {severity_counts['LOW']}")
        print(f"\nOverall Risk Score:             {self.risk_score}/100")

        risk_level = self._get_risk_level(self.risk_score)
        print(f"Security Status:                {risk_level}")

        # SAST Results
        if self.scan_results['sast']:
            print("\nüîç SAST FINDINGS")
            print("-" * 80)
            for i, vuln in enumerate(self.scan_results['sast'][:3], 1):
                print(f"\n{i}. {vuln['type']} [{vuln['severity']}]")
                print(f"   File: {vuln['file']}:{vuln['line']}")
                print(f"   CWE: {vuln['cwe']} | OWASP: {vuln['owasp']}")
                print(f"   Description: {vuln['description']}")
                print(f"   Remediation: {vuln['remediation']}")

        # Secrets Detection
        if self.scan_results['secrets']:
            print("\nüîê SECRETS DETECTED")
            print("-" * 80)
            for i, secret in enumerate(self.scan_results['secrets'][:3], 1):
                print(f"\n{i}. {secret['type']} [{secret['severity']}]")
                print(f"   File: {secret['file']}:{secret['line']}")
                print(f"   Secret Hash: {secret['secret_hash']}")
                print(f"   Leaked to Git: {'YES ‚ö†Ô∏è' if secret['leaked_to_git'] else 'NO'}")
                print(f"   Action: {secret['remediation']}")

        # Dependency Vulnerabilities
        if self.scan_results['dependencies']:
            print("\nüì¶ VULNERABLE DEPENDENCIES")
            print("-" * 80)
            for i, dep in enumerate(self.scan_results['dependencies'][:3], 1):
                print(f"\n{i}. {dep['package']} {dep['current_version']} [{dep['severity']}]")
                print(f"   CVE: {dep['vulnerability']} | CVSS: {dep['cvss_score']}")
                print(f"   Issue: {dep['description']}")
                print(f"   Fix: {dep['remediation']}")

        # Container Security
        if self.scan_results['container']:
            print("\nüê≥ CONTAINER SECURITY ISSUES")
            print("-" * 80)
            for i, issue in enumerate(self.scan_results['container'][:3], 1):
                print(f"\n{i}. {issue['type']} [{issue['severity']}]")
                print(f"   Description: {issue['description']}")
                print(f"   Remediation: {issue['remediation']}")

        # DAST Results
        if self.scan_results['dast']:
            print("\nüåê DAST FINDINGS")
            print("-" * 80)
            for i, vuln in enumerate(self.scan_results['dast'][:3], 1):
                print(f"\n{i}. {vuln['type']} [{vuln['severity']}]")
                print(f"   Endpoint: {vuln['endpoint']}")
                print(f"   Issue: {vuln['description']}")
                print(f"   Fix: {vuln['remediation']}")

        # Recommendations
        print("\nüí° SECURITY RECOMMENDATIONS")
        print("-" * 80)

        if severity_counts['CRITICAL'] > 0:
            print("\nüö® IMMEDIATE ACTION REQUIRED:")
            print(f"  {severity_counts['CRITICAL']} critical vulnerabilities must be fixed before deployment")
            print("  ‚Ä¢ Block pipeline execution")
            print("  ‚Ä¢ Notify security team")
            print("  ‚Ä¢ Remediate within 24 hours")

        if severity_counts['HIGH'] > 0:
            print(f"\n‚ö†Ô∏è  HIGH PRIORITY:")
            print(f"  {severity_counts['HIGH']} high severity issues detected")
            print("  ‚Ä¢ Fix before next release")
            print("  ‚Ä¢ Create security tickets")

        if len(self.scan_results['secrets']) > 0:
            print(f"\nüîê SECRETS MANAGEMENT:")
            print(f"  {len(self.scan_results['secrets'])} secrets found in code")
            print("  ‚Ä¢ Rotate all exposed credentials immediately")
            print("  ‚Ä¢ Implement secret management (HashiCorp Vault, AWS Secrets Manager)")
            print("  ‚Ä¢ Add pre-commit hooks to prevent future leaks")

        if len(self.scan_results['dependencies']) > 0:
            print(f"\nüì¶ DEPENDENCY UPDATES:")
            print(f"  {len(self.scan_results['dependencies'])} vulnerable packages")
            print("  ‚Ä¢ Run: pip install --upgrade [package]")
            print("  ‚Ä¢ Enable automated dependency scanning (Dependabot, Snyk)")

        # Pass/Fail Decision
        print(f"\n{'='*80}")
        if severity_counts['CRITICAL'] > 0:
            print("‚ùå PIPELINE STATUS: FAILED")
            print("   Critical vulnerabilities must be resolved before deployment")
        elif severity_counts['HIGH'] > 3:
            print("‚ö†Ô∏è  PIPELINE STATUS: WARNING")
            print("   Multiple high severity issues - review required")
        else:
            print("‚úÖ PIPELINE STATUS: PASSED")
            print("   Security scan completed successfully")
        print(f"{'='*80}\n")

    def _get_risk_level(self, score):
        """Convert risk score to risk level"""
        if score >= 75:
            return "üî¥ CRITICAL RISK"
        elif score >= 50:
            return "üü† HIGH RISK"
        elif score >= 25:
            return "üü° MEDIUM RISK"
        else:
            return "üü¢ LOW RISK"

    def visualize_security_findings(self):
        """Create comprehensive visualization of security scan results"""
        fig = plt.figure(figsize=(20, 12))

        # 1. Vulnerabilities by Severity
        ax1 = plt.subplot(3, 3, 1)
        severity_counts = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
        for results in self.scan_results.values():
            for item in results:
                sev = item.get('severity', 'LOW')
                severity_counts[sev] += 1

        colors_sev = {'CRITICAL': '#FF0000', 'HIGH': '#FF6B6B', 'MEDIUM': '#FFA500', 'LOW': '#4ECDC4'}
        bars = ax1.bar(severity_counts.keys(), severity_counts.values(),
                      color=[colors_sev[k] for k in severity_counts.keys()],
                      edgecolor='black', linewidth=1.5)
        ax1.set_title('Vulnerabilities by Severity', fontsize=14, fontweight='bold')
        ax1.set_ylabel('Count')
        for bar in bars:
            height = bar.get_height()
            ax1.text(bar.get_x() + bar.get_width()/2., height,
                    f'{int(height)}', ha='center', va='bottom', fontweight='bold')
        ax1.grid(True, alpha=0.3, axis='y')

        # 2. Vulnerabilities by Scan Type
        ax2 = plt.subplot(3, 3, 2)
        scan_counts = {k: len(v) for k, v in self.scan_results.items()}
        colors_scan = ['#667eea', '#f093fb', '#4facfe', '#00f2fe', '#43e97b']
        ax2.barh(list(scan_counts.keys()), list(scan_counts.values()),
                color=colors_scan, edgecolor='black')
        ax2.set_title('Findings by Scan Type', fontsize=14, fontweight='bold')
        ax2.set_xlabel('Count')
        for i, v in enumerate(scan_counts.values()):
            ax2.text(v + 0.2, i, str(v), va='center', fontweight='bold')
        ax2.grid(True, alpha=0.3, axis='x')

        # 3. Risk Score Gauge
        ax3 = plt.subplot(3, 3, 3)
        theta = np.linspace(0, np.pi, 100)
        radius = 1

        # Color segments for gauge
        colors_gauge = ['#4ECDC4', '#FFD700', '#FFA500', '#FF6B6B', '#FF0000']
        segments = 5
        for i in range(segments):
            start_angle = i * np.pi / segments
            end_angle = (i + 1) * np.pi / segments
            theta_seg = np.linspace(start_angle, end_angle, 20)
            x_seg = radius * np.cos(theta_seg)
            y_seg = radius * np.sin(theta_seg)
            ax3.fill_between(x_seg, 0, y_seg, color=colors_gauge[i], alpha=0.6)

        # Score needle
        needle_angle = np.pi * (1 - self.risk_score/100)
        ax3.plot([0, radius * 0.9 * np.cos(needle_angle)],
                [0, radius * 0.9 * np.sin(needle_angle)],
                'k-', linewidth=3)
        ax3.plot(0, 0, 'ko', markersize=10)

        ax3.set_xlim(-1.2, 1.2)
        ax3.set_ylim(-0.2, 1.2)
        ax3.set_aspect('equal')
        ax3.axis('off')
        ax3.text(0, -0.1, f'Risk Score\n{self.risk_score}/100',
                ha='center', fontsize=14, fontweight='bold')
        risk_level = self._get_risk_level(self.risk_score)
        ax3.text(0, -0.3, risk_level, ha='center', fontsize=10)
        ax3.set_title('Overall Security Risk', fontsize=14, fontweight='bold')

        # 4. Top Vulnerability Types
        ax4 = plt.subplot(3, 3, 4)
        vuln_types = {}
        for results in self.scan_results.values():
            for item in results:
                vtype = item.get('type', 'Unknown')
                vuln_types[vtype] = vuln_types.get(vtype, 0) + 1

        top_vulns = dict(sorted(vuln_types.items(), key=lambda x: x[1], reverse=True)[:8])
        if top_vulns:
            ax4.barh(list(top_vulns.keys()), list(top_vulns.values()),
                    color='#f093fb', edgecolor='black')
            ax4.set_title('Top Vulnerability Types', fontsize=14, fontweight='bold')
            ax4.set_xlabel('Count')
            for i, v in enumerate(top_vulns.values()):
                ax4.text(v + 0.05, i, str(v), va='center', fontweight='bold')
        ax4.grid(True, alpha=0.3, axis='x')

        # 5. OWASP Top 10 Coverage
        ax5 = plt.subplot(3, 3, 5)
        owasp_categories = {}
        for vuln in self.scan_results['sast']:
            owasp = vuln.get('owasp', 'Unknown')
            if owasp != 'Unknown':
                owasp_categories[owasp] = owasp_categories.get(owasp, 0) + 1

        if owasp_categories:
            ax5.bar(range(len(owasp_categories)), list(owasp_categories.values()),
                   color='#667eea', edgecolor='black')
            ax5.set_xticks(range(len(owasp_categories)))
            ax5.set_xticklabels([k.split('-')[0].strip() for k in owasp_categories.keys()],
                               rotation=45, ha='right')
            ax5.set_title('OWASP Top 10 Violations', fontsize=14, fontweight='bold')
            ax5.set_ylabel('Count')
        ax5.grid(True, alpha=0.3, axis='y')

        # 6. Secrets Distribution
        ax6 = plt.subplot(3, 3, 6)
        if self.scan_results['secrets']:
            secret_types = {}
            for secret in self.scan_results['secrets']:
                stype = secret['type']
                secret_types[stype] = secret_types.get(stype, 0) + 1

            labels = list(secret_types.keys())
            sizes = list(secret_types.values())
            colors_pie = plt.cm.Reds(np.linspace(0.4, 0.8, len(sizes)))

            ax6.pie(sizes, labels=labels, autopct='%1.1f%%', colors=colors_pie,
                   startangle=90, textprops={'fontsize': 9, 'weight': 'bold'})
            ax6.set_title('Exposed Secrets by Type', fontsize=14, fontweight='bold')
        else:
            ax6.text(0.5, 0.5, 'No Secrets\nDetected', ha='center', va='center',
                    fontsize=14, color='green', fontweight='bold')
            ax6.set_xlim(0, 1)
            ax6.set_ylim(0, 1)
            ax6.axis('off')
            ax6.set_title('Exposed Secrets', fontsize=14, fontweight='bold')

        # 7. Vulnerable Dependencies
        ax7 = plt.subplot(3, 3, 7)
        if self.scan_results['dependencies']:
            dep_severity = {'CRITICAL': 0, 'HIGH': 0, 'MEDIUM': 0, 'LOW': 0}
            for dep in self.scan_results['dependencies']:
                dep_severity[dep['severity']] += 1

            x = list(dep_severity.keys())
            y = list(dep_severity.values())
            colors_dep = [colors_sev[k] for k in x]

            bars = ax7.bar(x, y, color=colors_dep, edgecolor='black', linewidth=1.5)
            ax7.set_title('Dependency Vulnerabilities', fontsize=14, fontweight='bold')
            ax7.set_ylabel('Count')
            for bar in bars:
                height = bar.get_height()
                if height > 0:
                    ax7.text(bar.get_x() + bar.get_width()/2., height,
                            f'{int(height)}', ha='center', va='bottom', fontweight='bold')
        ax7.grid(True, alpha=0.3, axis='y')

        # 8. Security Scan Coverage
        ax8 = plt.subplot(3, 3, 8)
        scan_labels = ['SAST', 'Secrets', 'Dependencies', 'Container', 'DAST']
        scan_coverage = [
            100 if len(self.scan_results['sast']) > 0 else 0,
            100 if len(self.scan_results['secrets']) > 0 else 0,
            100 if len(self.scan_results['dependencies']) > 0 else 0,
            100 if len(self.scan_results['container']) > 0 else 0,
            100 if len(self.scan_results['dast']) > 0 else 0
        ]

        colors_coverage = ['#4ECDC4' if c == 100 else '#FF6B6B' for c in scan_coverage]
        bars = ax8.barh(scan_labels, scan_coverage, color=colors_coverage, edgecolor='black')
        ax8.set_title('Security Scan Coverage', fontsize=14, fontweight='bold')
        ax8.set_xlabel('Coverage (%)')
        ax8.set_xlim(0, 110)
        for i, v in enumerate(scan_coverage):
            ax8.text(v + 2, i, f'{int(v)}%', va='center', fontweight='bold')
        ax8.grid(True, alpha=0.3, axis='x')

        # 9. Pipeline Decision
        ax9 = plt.subplot(3, 3, 9)
        critical_count = severity_counts['CRITICAL']
        high_count = severity_counts['HIGH']

        if critical_count > 0:
            status = 'FAILED'
            status_color = '#FF0000'
            icon = '‚ùå'
        elif high_count > 3:
            status = 'WARNING'
            status_color = '#FFA500'
            icon = '‚ö†Ô∏è'
        else:
            status = 'PASSED'
            status_color = '#4ECDC4'
            icon = '‚úÖ'

        ax9.text(0.5, 0.6, icon, ha='center', va='center', fontsize=80)
        ax9.text(0.5, 0.3, f'Pipeline\n{status}', ha='center', va='center',
                fontsize=18, fontweight='bold', color=status_color)
        ax9.set_xlim(0, 1)
        ax9.set_ylim(0, 1)
        ax9.axis('off')
        ax9.set_title('Deployment Decision', fontsize=14, fontweight='bold')

        plt.tight_layout()
        plt.savefig('cicd_security_scan.png', dpi=300, bbox_inches='tight')
        print("\n‚úì Visualization saved as 'cicd_security_scan.png'")
        plt.show()

def main():
    print("üîí CI/CD Pipeline Security Scanner with SAST/DAST Integration")
    print("=" * 80)

    scanner = CICDSecurityScanner()

    # Step 1: Generate simulated codebase
    print("\nüìÅ Step 1: Loading codebase for scanning...")
    code_files = scanner.simulate_codebase()
    print(f"‚úì Loaded {len(code_files)} files for analysis")

    # Step 2: Run SAST
    print("\n" + "="*80)
    print("SECURITY SCAN PHASE - STATIC ANALYSIS")
    print("="*80)
    scanner.run_sast_scan(code_files)

    # Step 3: Run Secrets Detection
    scanner.run_secrets_scan(code_files)

    # Step 4: Run Dependency Scan
    scanner.run_dependency_scan(code_files['requirements.txt'])

    # Step 5: Run Container Scan
    scanner.run_container_scan(code_files['Dockerfile'])

    # Step 6: Run DAST
    print("\n" + "="*80)
    print("SECURITY SCAN PHASE - DYNAMIC ANALYSIS")
    print("="*80)
    scanner.run_dast_scan()

    # Step 7: Calculate Risk Score
    print("\nüìä Step 7: Calculating overall security risk score...")
    risk_score = scanner.calculate_risk_score()
    print(f"‚úì Risk Score: {risk_score}/100")

    # Step 8: Generate Report
    scanner.generate_pipeline_report()

    # Step 9: Visualize
    print("\nüìä Step 9: Creating security visualization dashboard...")
    scanner.visualize_security_findings()

    print("\n‚úÖ Security scan complete!")
    print("\nüìÅ Generated files:")
    print("  - cicd_security_scan.png (9-panel security dashboard)")

    # Summary
    total_issues = sum(len(v) for v in scanner.scan_results.values())
    critical_issues = sum(1 for results in scanner.scan_results.values()
                         for item in results if item.get('severity') == 'CRITICAL')

    print(f"\nüìä FINAL SUMMARY:")
    print(f"  Total Security Issues: {total_issues}")
    print(f"  Critical Issues: {critical_issues}")
    print(f"  Risk Score: {risk_score}/100")

    if critical_issues > 0:
        print(f"\n‚ùå DEPLOYMENT BLOCKED: {critical_issues} critical issues must be resolved")
        print("   Action Required: Fix critical vulnerabilities before proceeding")
    else:
        print(f"\n‚úÖ DEPLOYMENT APPROVED: No critical issues detected")
        print("   Recommendation: Review and fix remaining issues in next sprint")

if __name__ == "__main__":
    main()